import _sinon, { SinonStub } from 'sinon';

/**
 * A type that represents the response of a mock. This could be a value, or a
 * function that in turn returns a value.
 */
export type MockResponse<T> = T | ((...args: unknown[]) => T);

/**
 * Class that creates a mock method on an object, and provides useful methods
 * to track the response returned on each call.
 *
 * <p>
 * This class is not meant to be instantiated directly, but is designed for
 * use within the [ObjectMock]{@link ObjectMock} class.
 * </p
 * @typeparam T The type of instance that is being mocked.
 * @typeparam U The type of the response returned by the mock.
 */
export default class Mock<T, U> {
    private _instance: T;
    private _methodName: keyof T;
    private _stub: SinonStub;
    private _responses: U[];

    /**
     * @param instance The object instance on which the method will be mocked.
     * @param  methodName The name of the method on the object that needs to be
     * mocked. If the specified method does not exist, a placeholder method will
     * be injected into the instance which will then be mocked.
     *
     * @param retValue A return value that will be returned by the mock
     * method. If a function is passed in, the function will be invoked, and
     * ther return value of the function will be returned as the response.
     */
    constructor(instance: T, methodName: string, retValue: MockResponse<U>) {
        if (
            !instance ||
            instance instanceof Array ||
            typeof instance !== 'object'
        ) {
            throw new Error('Invalid instance specified (arg #1)');
        }
        if (typeof methodName !== 'string' || methodName.length <= 0) {
            throw new Error('Invalid methodName specified (arg #2)');
        }

        this._instance = instance;
        this._methodName = methodName as keyof T;

        if (typeof instance[this._methodName] !== 'function') {
            const dummyMethod = (() => undefined) as  (T &object)[keyof T];
            instance[this._methodName] = dummyMethod;
        }
        this._responses = [];
        this._stub = _sinon.stub(this._instance, this._methodName as keyof T);
        this._stub.callsFake((...args) => {
            const ret: U =
                typeof retValue === 'function'
                    ? (retValue as (...args: unknown[]) => U)(...args)
                    : retValue;
            this._responses.push(ret);
            return ret;
        });
    }

    /**
     * Returns a reference to the instance object that has the mocks applied to
     * it.
     */
    get instance(): T {
        return this._instance;
    }

    /**
     * Returns the name of the mock, which is the name of the method that has
     * been mocked.
     */
    get methodName(): string {
        return this._methodName as string;
    }

    /**
     * Returns a reference to the stub method generated by this class. This
     * property can be used to examine the call history and parameters of
     * the mocked method.
     */
    get stub(): SinonStub {
        return this._stub;
    }

    /**
     * Returns a list of responses returned by the mock up to the current time.
     * Responses may be promises depending on how the mock has been configured.
     */
    get responses(): U[] {
        return this._responses;
    }

    /**
     * Returns the response from the first mock invocation. If the mock has not
     * been invoked yet, an Error object will be returned.
     */
    get ret(): U | Error {
        if (this.responses.length <= 0) {
            return new Error('Method has not yet been called');
        }
        return this.responses[0];
    }

    /**
     * Clears all responses that have been tracked up to this point, and also
     * resets the mock's call history.
     */
    reset(): void {
        this.responses.splice(0);
        this.stub.resetHistory();
    }
}
